module Stack

import Data.HVect

import Effects
import Effect.Random
import Effect.State
import Effect.StdIO


--------------------------------
-- Stack Language Interpreter --
--------------------------------

-- Goals:
--   * show off dependent types
--   * show off effects system


-- The type of the stack: a vector containing the type of each
-- value on the stack.
StackT : Nat -> Type
StackT n = Vect n Type

-- The stack: a heterogeneous vector.
Stack : StackT n -> Type
Stack ts = HVect ts

-- Just an abbreviation.
I : Type
I = Integer


-- A block associating types with variable names to keep definitions clean.
using (ts : StackT i, us : StackT j, vs : StackT k)

  -- The type of each command describes its effect on the stack.
  data Cmd : StackT n -> StackT m -> Type where
    Push  : a ->      Cmd ts             (a :: ts)
    Add   :           Cmd (I :: I :: ts) (I :: ts)
    Save  :           Cmd (I :: ts)      (I :: ts)
    Load  :           Cmd ts             (I :: ts)
    Rand  : I ->      Cmd ts             (I :: ts)
    Print : Show a => Cmd (a :: ts)      ts

  
  -- An effectful command interpreter.
  cmd : (Handler State m, Handler Random m, Handler StdIO m) =>
        Cmd ts us -> Stack ts ->
        {[STATE I, RND, STDIO]} Eff m (Stack us)
  cmd (Push a) s             = return (a :: s)
  cmd Add      (x :: y :: s) = return ((x + y) :: s)
  cmd Save     (x :: s)      = do put x; return (x :: s)
  cmd Load     s             = do x <- get; return (x :: s)
  cmd (Rand n) s             = do i <- rndInt 0 n; return (i :: s)
  cmd Print    (a :: s)      = do putStrLn (show a); return s


  -- A program is a well-typed sequence of commands.
  -- In Idris, [a,b,c] macro-expands to (a :: b :: c :: Nil), so these
  -- constructor names allow us to use nice list concrete syntax.
  data Prog : StackT n -> StackT m -> Type where
    Nil  : Prog ts ts
    (::) : Cmd ts us -> Prog us vs -> Prog ts vs

  
  -- An effectful program interpreter.
  prog : (Handler State m, Handler Random m, Handler StdIO m) =>
         Prog ts us -> Stack ts ->
         {[STATE I, RND, STDIO]} Eff m (Stack us)
  prog Nil      s = return s
  prog (c :: p) s = cmd c s >>= prog p

  
  -- Execute a program in the context of the IO monad and a default
  -- environment generated by the effects library.
  exec : Prog [] us -> IO (Stack us)
  exec p = run (prog p [])

  -- Examples from Idris REPL (:x runs an IO action):
  --
  -- > :x exec [Push 2, Rand 7, Save, Print, Load, Add, Print]
  -- 3
  -- 5
  -- MkIO (\w => prim_io_return []) : IO (HVect [])
  --
  -- > :x exec [Push 2, Add]
  -- Can't unify
  --         Cmd (Integer :: (Integer :: ts)) (Integer :: ts)
  -- with
  --         Cmd [a] us
  -- Specifically:
  --         Can't unify
  --                 Integer :: ts
  --         with
  --                 []
